from typing import List, Tuple

import numpy as np


def split_uniformly(
    data: np.ndarray,
    labels: np.ndarray,
    n_clients: int
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """
    Split data and labels into clients uniformly.

    Args:
        data: shape(N, ...)
        labels: shape(N, )
        n_clients: number of clients

    Returns:
        List of (data, labels).
    """
    if data.shape[0] < n_clients:
        raise ValueError(
            "The length of 'data' is less than 'n_clients'. "
            f'data.shape: {data.shape}, n_clients: {n_clients}'
        )
    data, labels = _shuffle_together(data, labels)
    return list(zip(np.array_split(data, n_clients), np.array_split(labels, n_clients)))


def split_dirichlet_quantity(
    data: np.ndarray,
    labels: np.ndarray,
    n_clients: int,
    alpha: float,
    min_size: int = 1
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """
    Split data and labels into clients. The number of samples per client
    is generated by Dirichlet distributions.

    Args:
        data: shape(N, ...)
        labels: shape(N, )
        n_clients: number of clients
        alpha: parameter of Dirichlet distribution
        min_size: The number of samples per client will be greater than
            or equal to `min_size`.

    Returns:
        List of (data, labels).
    """
    n = len(data)
    if n_clients * min_size > n:
        raise ValueError(
            f"'n_clients * min_size' must be less than or equal to the number of samples."
        )
    data, labels = _shuffle_together(data, labels)
    while True:
        proportion = np.random.dirichlet(np.repeat(alpha, n_clients))  # shape(n_clients, )
        clients_labels = _array_split_by_ratio(labels, proportion)
        if min(len(labels) for labels in clients_labels) >= min_size:
            clients_data = _array_split_by_ratio(data, proportion)
            result = list(zip(clients_data, clients_labels))
            return result


def split_dirichlet_label(
    data: np.ndarray,
    labels: np.ndarray,
    n_clients: int,
    alpha: float,
    min_size: int = 1
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """
    Split data and labels into clients. The distribution of each class
    is generated by Dirichlet distributions.

    Args:
        data: shape(N, ...)
        labels: shape(N, )
        n_clients: number of clients
        alpha: parameter of Dirichlet distribution
        min_size: The number of samples per client will be greater than
            or equal to `min_size`.

    Returns:
        List of (data, labels).
    """
    classes = np.unique(labels)
    n_classes = len(classes)
    proportion = np.random.dirichlet(
        alpha=np.repeat(alpha, n_clients),
        size=n_classes
    )  # shape(n_classes, n_clients), sum by row is 1.0
    while True:
        clients = _split_by_client_proportion(
            data,
            _map_labels_to_continuous(labels, classes),
            proportion
        )
        if all(len(labels) >= min_size for _, labels in clients):
            break
    return [(client[0], _recover_labels(client[1], classes)) for client in clients]


def split_by_label(
    data: np.ndarray,
    labels: np.ndarray,
    n_clients: int,
    n_class_per_client: int
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """
    Split data and labels into clients. Each client has `n_class_per_client` classes.

    Args:
        data: shape(N, ...)
        labels: shape(N, )
        n_clients: number of clients
        n_class_per_client: each client has `n_class_per_client` classes

    Returns:
        List of (data, labels).
    """
    classes = np.unique(labels)
    n_classes = len(classes)
    if n_class_per_client > n_classes:
        raise ValueError("'n_class_per_client' should be less than or equal to 'n_classes'")
    if n_clients * n_class_per_client < n_classes:
        raise ValueError('Each class should be assigned to at least one client.')
    original_classes = classes
    classes = _map_labels_to_continuous(classes, classes)
    np.random.shuffle(classes)
    # ensure that len(classes_sequence) >= n_clients * n_class_per_client
    repeat_count = _ceil_div(n_clients * n_class_per_client, n_classes)
    classes_sequence = np.tile(classes, repeat_count)
    clients_classes = [
        classes_sequence[(i * n_class_per_client):((i + 1) * n_class_per_client)]
        for i in range(n_clients)
    ]
    proportion = np.zeros((n_classes, n_clients))
    for client in range(n_clients):
        for c in clients_classes[client]:
            proportion[c, client] = 1
    clients = _split_by_client_proportion(
        data,
        _map_labels_to_continuous(labels, original_classes),
        proportion
    )
    return [(client[0], _recover_labels(client[1], original_classes)) for client in clients]


def _ceil_div(a: int, b: int) -> int:
    """Ensure that `ceil_div(a, b) * b >= a`"""
    return (a + b - 1) // b


def _split_by_client_proportion(
    data: np.ndarray,
    labels: np.ndarray,
    proportion: np.ndarray
) -> List[Tuple[np.ndarray, np.ndarray]]:
    """
    Args:
        data: shape(N, ...)
        labels: shape(N, ), label must be continuous and start from zero
        proportion: shape(n_classes, n_clients), each row is a client proportion of a class

    Returns:
        List of (data, labels).
    """
    n_classes, n_clients = proportion.shape
    if not(labels.min() == 0 and labels.max() == n_classes - 1):
        raise ValueError(f'label must be continuous and start from zero')
    data, labels = _shuffle_together(data, labels)
    clients_data = [[] for _ in range(n_clients)]
    clients_labels = [[] for _ in range(n_clients)]
    for c in range(n_classes):
        for client, client_data in enumerate(_array_split_by_ratio(data[labels == c], proportion[c])):
            clients_data[client].append(client_data)
            clients_labels[client].append(np.repeat(c, len(client_data)))
    return [(np.concatenate(clients_data[client]), np.concatenate(clients_labels[client])) for client in range(n_clients)]


def _shuffle_together(*arrays: np.ndarray) -> Tuple[np.ndarray, ...]:
    """
    Shuffle multiple arrays together. Multidimensional arrays will be
    shuffled along the first axis.
    """
    n = len(arrays[0])
    if any(len(array) != n for array in arrays):
        raise ValueError('All arrays must be of the same length.')
    indices = np.random.permutation(n)
    return tuple(array[indices] for array in arrays)


def _array_split_by_ratio(array: np.ndarray, ratios: np.ndarray) -> List[np.ndarray]:
    ratios = ratios / ratios.sum()
    n = len(array)
    sample_nums = (n * ratios).round().astype(np.int64)
    split_points = np.cumsum(sample_nums)[:-1]
    arrays = np.array_split(array, split_points)
    return arrays


def _map_labels_to_continuous(labels: np.ndarray, indexer: np.ndarray) -> np.ndarray:
    """Label of `indexer[i]` will be mapped to `i`."""
    mapping = {label: i for i, label in enumerate(indexer)}
    return np.array([mapping[label] for label in labels])


def _recover_labels(labels: np.ndarray, indexer: np.ndarray) -> np.ndarray:
    """Label `i` will be mapped to `indexer[i]`."""
    return np.array([indexer[label] for label in labels])
